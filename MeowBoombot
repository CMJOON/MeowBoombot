services:
  - type: web
    name: telegram-bot
    env: python
    buildCommand: pip install -r requirements.txt
    startCommand: python bot.py
    plan: free

import logging
import random
import asyncio
from typing import Dict, List, Optional
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes

# å¯ç”¨æ—¥å¿—
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)
logger = logging.getLogger(__name__)

# å¡ç‰Œç±»å‹
CARD_TYPES = {
    'exploding_kitten': 'ğŸ’£ ç‚¸å¼¹çŒ«',
    'defuse': 'ğŸ›¡ï¸ æ‹†å¼¹',
    'skip': 'â­ï¸ è·³è¿‡',
    'attack': 'âš”ï¸ æ”»å‡»',
    'see_future': 'ğŸ”® é¢„çŸ¥æœªæ¥',
    'shuffle': 'ğŸ”€ æ´—ç‰Œ',
    'favor': 'ğŸ¤ æ©æƒ ',
    'nope': 'âŒ æ‹’ç»',
    'normal_cat': 'ğŸ± æ™®é€šçŒ«',
}

class Card:
    def __init__(self, card_type: str):
        self.type = card_type
        self.name = CARD_TYPES[card_type]
    
    def __str__(self):
        return self.name

class Player:
    def __init__(self, user_id: int, username: str):
        self.user_id = user_id
        self.username = username
        self.hand = []
        self.is_alive = True
        self.turns_to_take = 1
    
    def add_card(self, card: Card):
        self.hand.append(card)
    
    def remove_card(self, card_type: str) -> Optional[Card]:
        for i, card in enumerate(self.hand):
            if card.type == card_type:
                return self.hand.pop(i)
        return None
    
    def has_card(self, card_type: str) -> bool:
        return any(card.type == card_type for card in self.hand)
    
    def get_hand_display(self) -> str:
        if not self.hand:
            return "æ‰‹ç‰Œä¸ºç©º"
        hand_counts = {}
        for card in self.hand:
            hand_counts[card.name] = hand_counts.get(card.name, 0) + 1
        return '\n'.join([f"{name}: {count}" for name, count in hand_counts.items()])

class Game:
    def __init__(self, chat_id: int):
        self.chat_id = chat_id
        self.players = {}
        self.deck = []
        self.discard_pile = []
        self.current_player_index = 0
        self.game_started = False
        self.turn_direction = 1
        self.waiting_for_action = False
        self.last_played_card = None
    
    def add_player(self, user_id: int, username: str):
        if user_id not in self.players and len(self.players) < 5:
            self.players[user_id] = Player(user_id, username)
            return True
        return False
    
    def remove_player(self, user_id: int):
        if user_id in self.players:
            del self.players[user_id]
    
    def create_deck(self):
        # æ ¹æ®ç©å®¶æ•°é‡åˆ›å»ºç‰Œç»„
        num_players = len(self.players)
        
        # åŸºç¡€ç‰Œç»„
        cards = []
        
        # æ·»åŠ ç‚¸å¼¹çŒ« (æ¯”ç©å®¶æ•°å°‘1å¼ )
        for _ in range(num_players - 1):
            cards.append(Card('exploding_kitten'))
        
        # æ·»åŠ æ‹†å¼¹å¡ (æ¯äºº1å¼ ï¼Œå¤š1å¼ )
        for _ in range(num_players + 1):
            cards.append(Card('defuse'))
        
        # æ·»åŠ å…¶ä»–å¡ç‰Œ
        other_cards = [
            ('skip', 4), ('attack', 4), ('see_future', 5),
            ('shuffle', 4), ('favor', 4), ('nope', 5), ('normal_cat', 4)
        ]
        
        for card_type, count in other_cards:
            for _ in range(count):
                cards.append(Card(card_type))
        
        # æ´—ç‰Œ
        random.shuffle(cards)
        self.deck = cards
    
    def deal_cards(self):
        # æ¯ä¸ªç©å®¶å‘7å¼ ç‰Œï¼ˆåŒ…å«1å¼ æ‹†å¼¹å¡ï¼‰
        for player in self.players.values():
            player.add_card(Card('defuse'))
            for _ in range(6):
                if self.deck:
                    player.add_card(self.deck.pop())
    
    def get_current_player(self) -> Optional[Player]:
        alive_players = [p for p in self.players.values() if p.is_alive]
        if not alive_players:
            return None
        return alive_players[self.current_player_index % len(alive_players)]
    
    def next_turn(self):
        alive_players = [p for p in self.players.values() if p.is_alive]
        if len(alive_players) <= 1:
            return
        
        current = self.get_current_player()
        if current and current.turns_to_take > 1:
            current.turns_to_take -= 1
        else:
            self.current_player_index = (self.current_player_index + self.turn_direction) % len(alive_players)
            current = self.get_current_player()
            if current:
                current.turns_to_take = 1
    
    def draw_card(self, player: Player) -> Card:
        if not self.deck:
            return None
        
        card = self.deck.pop(0)
        if card.type == 'exploding_kitten':
            if player.has_card('defuse'):
                # ä½¿ç”¨æ‹†å¼¹å¡
                defuse = player.remove_card('defuse')
                self.discard_pile.append(defuse)
                # å°†ç‚¸å¼¹çŒ«æ”¾å›ç‰Œå †éšæœºä½ç½®
                if self.deck:
                    pos = random.randint(0, len(self.deck))
                    self.deck.insert(pos, card)
                else:
                    self.deck.append(card)
                return Card('defuse')  # è¿”å›æ‹†å¼¹å¡è¡¨ç¤ºå®‰å…¨
            else:
                # ç©å®¶è¢«æ·˜æ±°
                player.is_alive = False
                return card
        else:
            player.add_card(card)
            return card
    
    def get_game_status(self) -> str:
        alive_players = [p for p in self.players.values() if p.is_alive]
        status = f"ğŸ® æ¸¸æˆçŠ¶æ€\n"
        status += f"ğŸ‘¥ å­˜æ´»ç©å®¶: {len(alive_players)}\n"
        status += f"ğŸƒ å‰©ä½™å¡ç‰Œ: {len(self.deck)}\n\n"
        
        current = self.get_current_player()
        if current:
            status += f"ğŸ¯ å½“å‰å›åˆ: @{current.username}\n"
            if current.turns_to_take > 1:
                status += f"â° å‰©ä½™å›åˆæ•°: {current.turns_to_take}\n"
        
        return status

# å…¨å±€æ¸¸æˆç®¡ç†å™¨
games: Dict[int, Game] = {}

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """å¼€å§‹æ¸¸æˆå‘½ä»¤"""
    chat_id = update.effective_chat.id
    user = update.effective_user
    
    if chat_id not in games:
        games[chat_id] = Game(chat_id)
    
    game = games[chat_id]
    
    if game.game_started:
        await update.message.reply_text("æ¸¸æˆå·²ç»å¼€å§‹äº†ï¼")
        return
    
    if game.add_player(user.id, user.username or user.first_name):
        await update.message.reply_text(f"@{user.username or user.first_name} åŠ å…¥äº†æ¸¸æˆï¼\n"
                                      f"å½“å‰ç©å®¶æ•°: {len(game.players)}/5\n"
                                      f"ä½¿ç”¨ /join åŠ å…¥æ¸¸æˆï¼Œ/start_game å¼€å§‹æ¸¸æˆ")
    else:
        await update.message.reply_text("ä½ å·²ç»åœ¨æ¸¸æˆä¸­äº†ï¼Œæˆ–è€…æ¸¸æˆäººæ•°å·²æ»¡ï¼")

async def join_game(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """åŠ å…¥æ¸¸æˆå‘½ä»¤"""
    chat_id = update.effective_chat.id
    user = update.effective_user
    
    if chat_id not in games:
        await update.message.reply_text("è¿˜æ²¡æœ‰æ¸¸æˆå¼€å§‹ï¼ä½¿ç”¨ /start åˆ›å»ºæ¸¸æˆ")
        return
    
    game = games[chat_id]
    
    if game.game_started:
        await update.message.reply_text("æ¸¸æˆå·²ç»å¼€å§‹äº†ï¼Œæ— æ³•å†åŠ å…¥ï¼")
        return
    
    if game.add_player(user.id, user.username or user.first_name):
        await update.message.reply_text(f"@{user.username or user.first_name} åŠ å…¥äº†æ¸¸æˆï¼\n"
                                      f"å½“å‰ç©å®¶æ•°: {len(game.players)}/5")
    else:
        await update.message.reply_text("ä½ å·²ç»åœ¨æ¸¸æˆä¸­äº†ï¼Œæˆ–è€…æ¸¸æˆäººæ•°å·²æ»¡ï¼")

async def start_game(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """å¼€å§‹æ¸¸æˆ"""
    chat_id = update.effective_chat.id
    
    if chat_id not in games:
        await update.message.reply_text("è¿˜æ²¡æœ‰æ¸¸æˆï¼ä½¿ç”¨ /start åˆ›å»ºæ¸¸æˆ")
        return
    
    game = games[chat_id]
    
    if len(game.players) < 2:
        await update.message.reply_text("è‡³å°‘éœ€è¦2ä¸ªç©å®¶æ‰èƒ½å¼€å§‹æ¸¸æˆï¼")
        return
    
    if game.game_started:
        await update.message.reply_text("æ¸¸æˆå·²ç»å¼€å§‹äº†ï¼")
        return
    
    # åˆå§‹åŒ–æ¸¸æˆ
    game.create_deck()
    game.deal_cards()
    game.game_started = True
    
    # å‘é€æ¸¸æˆå¼€å§‹æ¶ˆæ¯
    players_list = '\n'.join([f"@{p.username}" for p in game.players.values()])
    await update.message.reply_text(f"ğŸ® ç‚¸å¼¹çŒ«æ¸¸æˆå¼€å§‹ï¼\n\n"
                                  f"å‚ä¸ç©å®¶:\n{players_list}\n\n"
                                  f"{game.get_game_status()}\n"
                                  f"è½®åˆ° @{game.get_current_player().username} è¡ŒåŠ¨ï¼")
    
    # å‘é€è¡ŒåŠ¨æŒ‰é’®
    keyboard = [
        [InlineKeyboardButton("ğŸ² æŠ½ç‰Œ", callback_data="draw")],
        [InlineKeyboardButton("ğŸƒ æŸ¥çœ‹æ‰‹ç‰Œ", callback_data="show_hand")],
        [InlineKeyboardButton("ğŸ¯ ä½¿ç”¨å¡ç‰Œ", callback_data="use_card")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text("é€‰æ‹©ä½ çš„è¡ŒåŠ¨:", reply_markup=reply_markup)

async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """å¤„ç†æŒ‰é’®ç‚¹å‡»"""
    query = update.callback_query
    await query.answer()
    
    chat_id = query.message.chat_id
    user_id = query.from_user.id
    
    if chat_id not in games:
        await query.edit_message_text("æ¸¸æˆä¸å­˜åœ¨ï¼")
        return
    
    game = games[chat_id]
    current_player = game.get_current_player()
    
    if not current_player or current_player.user_id != user_id:
        await query.edit_message_text("ä¸æ˜¯ä½ çš„å›åˆï¼")
        return
    
    action = query.data
    
    if action == "draw":
        # æŠ½ç‰Œ
        card = game.draw_card(current_player)
        if not card:
            await query.edit_message_text("ç‰Œå †å·²ç©ºï¼")
            return
        
        if card.type == 'exploding_kitten':
            # ç©å®¶è¢«æ·˜æ±°
            await query.edit_message_text(f"ğŸ’¥ @{current_player.username} æŠ½åˆ°äº†ç‚¸å¼¹çŒ«ï¼Œè¢«æ·˜æ±°äº†ï¼")
            
            # æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
            alive_players = [p for p in game.players.values() if p.is_alive]
            if len(alive_players) == 1:
                winner = alive_players[0]
                await context.bot.send_message(chat_id, f"ğŸ‰ æ¸¸æˆç»“æŸï¼@{winner.username} è·èƒœï¼")
                del games[chat_id]
                return
        elif card.type == 'defuse':
            await query.edit_message_text(f"ğŸ›¡ï¸ @{current_player.username} ä½¿ç”¨æ‹†å¼¹å¡åŒ–è§£äº†ç‚¸å¼¹çŒ«ï¼")
        else:
            await query.edit_message_text(f"@{current_player.username} æŠ½åˆ°äº† {card}")
        
        # ä¸‹ä¸€ä¸ªç©å®¶çš„å›åˆ
        game.next_turn()
        next_player = game.get_current_player()
        if next_player:
            keyboard = [
                [InlineKeyboardButton("ğŸ² æŠ½ç‰Œ", callback_data="draw")],
                [InlineKeyboardButton("ğŸƒ æŸ¥çœ‹æ‰‹ç‰Œ", callback_data="show_hand")],
                [InlineKeyboardButton("ğŸ¯ ä½¿ç”¨å¡ç‰Œ", callback_data="use_card")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await context.bot.send_message(chat_id, 
                                         f"{game.get_game_status()}\nè½®åˆ° @{next_player.username} è¡ŒåŠ¨ï¼",
                                         reply_markup=reply_markup)
    
    elif action == "show_hand":
        # æ˜¾ç¤ºæ‰‹ç‰Œ
        hand_display = current_player.get_hand_display()
        await query.edit_message_text(f"ğŸƒ ä½ çš„æ‰‹ç‰Œ:\n{hand_display}")
    
    elif action == "use_card":
        # ä½¿ç”¨å¡ç‰Œèœå•
        if not current_player.hand:
            await query.edit_message_text("ä½ æ²¡æœ‰å¯ç”¨çš„å¡ç‰Œï¼")
            return
        
        # åˆ›å»ºå¡ç‰Œä½¿ç”¨æŒ‰é’®
        unique_cards = {}
        for card in current_player.hand:
            if card.type not in ['exploding_kitten', 'defuse']:  # è¿™äº›å¡ä¸èƒ½ä¸»åŠ¨ä½¿ç”¨
                unique_cards[card.type] = card.name
        
        if not unique_cards:
            await query.edit_message_text("ä½ æ²¡æœ‰å¯ä»¥ä½¿ç”¨çš„å¡ç‰Œï¼")
            return
        
        keyboard = []
        for card_type, card_name in unique_cards.items():
            keyboard.append([InlineKeyboardButton(card_name, callback_data=f"play_{card_type}")])
        keyboard.append([InlineKeyboardButton("âŒ å–æ¶ˆ", callback_data="cancel")])
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text("é€‰æ‹©è¦ä½¿ç”¨çš„å¡ç‰Œ:", reply_markup=reply_markup)
    
    elif action.startswith("play_"):
        # ä½¿ç”¨ç‰¹å®šå¡ç‰Œ
        card_type = action[5:]  # å»æ‰ "play_" å‰ç¼€
        
        if not current_player.has_card(card_type):
            await query.edit_message_text("ä½ æ²¡æœ‰è¿™å¼ å¡ç‰Œï¼")
            return
        
        used_card = current_player.remove_card(card_type)
        game.discard_pile.append(used_card)
        
        # æ‰§è¡Œå¡ç‰Œæ•ˆæœ
        await execute_card_effect(context, game, current_player, card_type, query)
    
    elif action == "cancel":
        # å–æ¶ˆæ“ä½œï¼Œè¿”å›ä¸»èœå•
        keyboard = [
            [InlineKeyboardButton("ğŸ² æŠ½ç‰Œ", callback_data="draw")],
            [InlineKeyboardButton("ğŸƒ æŸ¥çœ‹æ‰‹ç‰Œ", callback_data="show_hand")],
            [InlineKeyboardButton("ğŸ¯ ä½¿ç”¨å¡ç‰Œ", callback_data="use_card")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text("é€‰æ‹©ä½ çš„è¡ŒåŠ¨:", reply_markup=reply_markup)

async def execute_card_effect(context, game, player, card_type, query):
    """æ‰§è¡Œå¡ç‰Œæ•ˆæœ"""
    chat_id = game.chat_id
    
    if card_type == 'skip':
        await query.edit_message_text(f"â­ï¸ @{player.username} ä½¿ç”¨äº†è·³è¿‡å¡ï¼Œç»“æŸå›åˆï¼")
        game.next_turn()
    
    elif card_type == 'attack':
        await query.edit_message_text(f"âš”ï¸ @{player.username} ä½¿ç”¨äº†æ”»å‡»å¡ï¼Œä¸‹ä¸ªç©å®¶éœ€è¦é¢å¤–æŠ½ä¸€å¼ ç‰Œï¼")
        game.next_turn()
        next_player = game.get_current_player()
        if next_player:
            next_player.turns_to_take = 2
    
    elif card_type == 'see_future':
        top_cards = game.deck[:3] if len(game.deck) >= 3 else game.deck[:]
        future_text = "ğŸ”® æœªæ¥3å¼ ç‰Œ:\n" + '\n'.join([f"{i+1}. {card}" for i, card in enumerate(top_cards)])
        await query.edit_message_text(f"@{player.username} ä½¿ç”¨äº†é¢„çŸ¥æœªæ¥ï¼\n{future_text}")
    
    elif card_type == 'shuffle':
        random.shuffle(game.deck)
        await query.edit_message_text(f"ğŸ”€ @{player.username} ä½¿ç”¨äº†æ´—ç‰Œå¡ï¼Œç‰Œå †è¢«é‡æ–°æ´—ç‰Œï¼")
    
    elif card_type == 'favor':
        # ç®€åŒ–ç‰ˆï¼šéšæœºä»å…¶ä»–ç©å®¶é‚£é‡Œè·å¾—ä¸€å¼ ç‰Œ
        alive_players = [p for p in game.players.values() if p.is_alive and p != player]
        if alive_players and any(p.hand for p in alive_players):
            target = random.choice([p for p in alive_players if p.hand])
            if target.hand:
                stolen_card = target.hand.pop(random.randint(0, len(target.hand)-1))
                player.add_card(stolen_card)
                await query.edit_message_text(f"ğŸ¤ @{player.username} ä½¿ç”¨äº†æ©æƒ å¡ï¼Œä» @{target.username} é‚£é‡Œè·å¾—äº†ä¸€å¼  {stolen_card}ï¼")
        else:
            await query.edit_message_text(f"ğŸ¤ @{player.username} ä½¿ç”¨äº†æ©æƒ å¡ï¼Œä½†æ²¡æœ‰ç›®æ ‡å¯ä»¥é€‰æ‹©ï¼")
    
    # å¦‚æœä¸æ˜¯è·³è¿‡å¡æˆ–æ”»å‡»å¡ï¼Œç»§ç»­å½“å‰ç©å®¶çš„å›åˆ
    if card_type not in ['skip', 'attack']:
        keyboard = [
            [InlineKeyboardButton("ğŸ² æŠ½ç‰Œ", callback_data="draw")],
            [InlineKeyboardButton("ğŸƒ æŸ¥çœ‹æ‰‹ç‰Œ", callback_data="show_hand")],
            [InlineKeyboardButton("ğŸ¯ ä½¿ç”¨å¡ç‰Œ", callback_data="use_card")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await context.bot.send_message(chat_id, "ç»§ç»­ä½ çš„å›åˆ:", reply_markup=reply_markup)
    else:
        # åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªç©å®¶
        next_player = game.get_current_player()
        if next_player:
            keyboard = [
                [InlineKeyboardButton("ğŸ² æŠ½ç‰Œ", callback_data="draw")],
                [InlineKeyboardButton("ğŸƒ æŸ¥çœ‹æ‰‹ç‰Œ", callback_data="show_hand")],
                [InlineKeyboardButton("ğŸ¯ ä½¿ç”¨å¡ç‰Œ", callback_data="use_card")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await context.bot.send_message(chat_id, 
                                         f"{game.get_game_status()}\nè½®åˆ° @{next_player.username} è¡ŒåŠ¨ï¼",
                                         reply_markup=reply_markup)

async def game_status(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """æ˜¾ç¤ºæ¸¸æˆçŠ¶æ€"""
    chat_id = update.effective_chat.id
    
    if chat_id not in games:
        await update.message.reply_text("æ²¡æœ‰æ­£åœ¨è¿›è¡Œçš„æ¸¸æˆï¼")
        return
    
    game = games[chat_id]
    
    if not game.game_started:
        players_list = '\n'.join([f"@{p.username}" for p in game.players.values()])
        await update.message.reply_text(f"æ¸¸æˆå°šæœªå¼€å§‹\n\nå‚ä¸ç©å®¶:\n{players_list}\n\nä½¿ç”¨ /start_game å¼€å§‹æ¸¸æˆ")
    else:
        await update.message.reply_text(game.get_game_status())

async def end_game(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ç»“æŸæ¸¸æˆ"""
    chat_id = update.effective_chat.id
    
    if chat_id in games:
        del games[chat_id]
        await update.message.reply_text("æ¸¸æˆå·²ç»“æŸï¼")
    else:
        await update.message.reply_text("æ²¡æœ‰æ­£åœ¨è¿›è¡Œçš„æ¸¸æˆï¼")

def main():
    """å¯åŠ¨æœºå™¨äºº"""
    # åœ¨è¿™é‡Œæ›¿æ¢ä¸ºä½ çš„Bot Token
    TOKEN = "7755544392:AAFtF8m9d0bGN3AjeVoqfiAxPg2gogoVOaU"
    
    # åˆ›å»ºåº”ç”¨
    application = Application.builder().token(TOKEN).build()
    
    # æ·»åŠ å¤„ç†å™¨
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("join", join_game))
    application.add_handler(CommandHandler("start_game", start_game))
    application.add_handler(CommandHandler("status", game_status))
    application.add_handler(CommandHandler("end", end_game))
    application.add_handler(CallbackQueryHandler(button_callback))
    
    # å¯åŠ¨æœºå™¨äºº
    print("ç‚¸å¼¹çŒ«æ¸¸æˆBotå¯åŠ¨ä¸­...")
    application.run_polling()

if __name__ == '__main__':
    main()
